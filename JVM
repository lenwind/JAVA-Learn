# Java 运行时数据区

* 方法区是Java的逻辑概念，Java8之前通过永久代实现，放在Java虚拟机中；Java8之后通过元空间实现，放在直接内存中，不会出现OOM，也能简化堆的实现复杂度。用于放置常量池、class相关信息（定义、变量、方法）。

  * 静态常量池：一个class文件一个常量池（类的全限定名，字段名称描述符，方法名称描述符，final字段），是编译期就确定的。
  * 运行时常量池：一个对象一个常量池，运行时装载的常量
  * 字符串常量池：全局唯一，通过一个hashtable的数据结构保存字符串，避免频繁创建重复的字符串对象，可以通jvm参数指定大小-XX:StringTableSize=99991
* 堆是用来保存创建的对象，分为新生代和老年代，默认1：2；新生代中又分为eden区和survival区，默认8：1：1
* 线程空间：

  * 虚拟机栈用于进行方法的调用，保存局部变量、动态链接、方法返回地址、操作数栈
  * 本地线程栈用于jvm执行native（代码逻辑通过c/c++实现）方法，是为了方便直接调用操作系统的接口，提高Java运行效率存在
  * PC计数器，用于保存当前线程执行的内存地址，用于实现线程的切换
* 直接内存：Java可以访问和控制系统内存，但一般会在JVM启动时就分配好内存，提高系统运行效率；但如果出现频繁IO，直接操作系统内存，可以减少直接内存到JVM内存的转换，提高效率。


## 为什么堆内存要分年轻代和老年代

JAVA作为高级语言，不用像C一样需要程序员手动释放内存，于是需要一个垃圾收集器来回收内存。根据垃圾回收的强弱分代假说——大多数对象都是朝生夕灭，熬过越久的对象越不容易被回收，自然而然可以根据对象的年龄（每进行一次垃圾收集，年龄加一），分为年轻代和老年代。


# **描述一个 Java 对象的生命周期**

对象的生命周期简略而言包括创建、存活、销毁。

## 创建

对象创建其实就是内存空间的分配。分配就涉及到堆的划分，一般而言，会直接在eden区划分一块区域给这个对象，但可能存在空间不足，这时就会触发yongGC，将在eden区的对象移动到survival区（注意，survival区超过50%又会复制到old区）；还存在一种情况，就是对象过大，为了减少内存复制搬移的损耗，会直接放到old区（内存担保）。分配内存还需要注意多线程并发的问题，在Java中，采用乐观锁或缓存表预分配解决；对于内存是否碎片化的特点，采用指针碰撞（新生代）或者空闲列表（老年代）分配地址。

## 存活

存活就是使用对象，涉及到内存地址的访问，采用对象句柄的间接访问或内存地址的直接访问方式。

## 销毁

最后是销毁，也就是GC的问题，究竟什么对象可以回收？怎么回收才比较高效、不影响系统运行效率？

JAVA提供了多种不同的垃圾收集器，但万变不离其宗，本质都是需要先进行垃圾标记、再进行垃圾回收。垃圾标记有引用计数法（存在循环引用问题）、根可达算法（树的遍历）；垃圾回收有清扫（效率高、但有内存碎片）、整理（慢、但没有内存碎片）、复制（效率中、没有内存碎片但浪费内存空间）。

而这几种垃圾回收的区别，也决定了其适用场景和所诞生的垃圾收集器的特点。

* ParNew 收集器：并行收集、用于新生代、标记-复制；serial的并行版
* ParallelScavenge 收集器：并行收集、用于新生代、标记-复制；吞吐量优先
* ParallelOld 收集器：并行搜集、用于老年代、标记-整理；吞吐量优先
* CMS 收集器：并行收集、老年代、标记-清理；响应优先，对垃圾收集进行的细化（初始gcRoot标记【快】、并发完整标记【慢】、重新标记【快】、并发清除【慢】）
* G1 收集器：并发收集、全局标记-整理，局部标记-复制，分region、大内存（2G以上），低延迟
